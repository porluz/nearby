# Use the latest 2.1 version of CircleCI pipeline process engine.
# See: https://circleci.com/docs/configuration-reference
version: 2.1

# Define a job to be invoked later in a workflow.
# See: https://circleci.com/docs/configuration-reference/#jobs
jobs:
  say-hello:
    # Specify the execution environment. You can specify an image from Docker Hub or use one of our convenience images from CircleCI's Developer Hub.
    # See: https://circleci.com/docs/configuration-reference/#executor-job
    docker:
      - image: cimg/base:stable
    # Add steps to the job
    # See: https://circleci.com/docs/configuration-reference/#steps
    steps:
      - checkout
      - run:
          name: "Say hello"
          command: "echo Hello, World!"
  create-coverage-report-prereq:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - run:
          name: Determine if test coverage job should be skipped
          command: |
            echo "Creating shared env variables"
            PR_NUMBER="${CIRCLE_PULL_REQUEST##*/}"
            COVERAGE_ARTIFACTS_URL="https://output.circle-artifacts.com/output/job/${CIRCLE_WORKFLOW_JOB_ID}/artifacts/${CIRCLE_NODE_INDEX}/coverage"
            ISSUES_API_ENDPOINT="https://api.github.com/repos/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/issues"
            PR_API_ENDPOINT="$ISSUES_API_ENDPOINT/$PR_NUMBER"
            ARTIFACT_URL="$COVERAGE_ARTIFACTS_URL/lcov-report/index.html"

            echo "Checking if the test coverage job should be skipped..."
            UI_CHANGES_DETECTED="$(.circleci/helpers/folder_has_changes.sh src)"
            COMMIT_SKIP_COVERAGE_MESSAGE_FOUND="$(.circleci/helpers/commit_summary_contains.sh skipTestCoverage)"
            PR_DESCRIPTION_SKIP_MESSAGE_FOUND="$(.circleci/helpers/pr_description_contains.sh $PR_API_ENDPOINT '**Reason for missing FE tests**:')"
            SKIP_FE_COVERAGE_CHECK="false"
            echo "completed setting env vars"
            # Check if any of the variables is  "true"
            if [ "$UI_CHANGES_DETECTED" == "true" ]; then
              # Check if at least one of the other two variables is "true"
              if [ "$COMMIT_SKIP_COVERAGE_MESSAGE_FOUND" == "true" ] || [ "$PR_DESCRIPTION_SKIP_MESSAGE_FOUND" == "true" ]; then
                SKIP_FE_COVERAGE_CHECK="true"
              fi
            fi
            echo "PR_NUMBER=$PR_NUMBER" >> /tmp/fe_coverage
            echo "COVERAGE_ARTIFACTS_URL=$COVERAGE_ARTIFACTS_URL" >> /tmp/fe_coverage
            echo "ISSUES_API_ENDPOINT=$ISSUES_API_ENDPOINT" >> /tmp/fe_coverage
            echo "PR_API_ENDPOINT=$PR_API_ENDPOINT" >> /tmp/fe_coverage
            echo "ARTIFACT_URL=$ARTIFACT_URL" >> /tmp/fe_coverage
            echo "Completed determining if the test coverage job should be skipped."
      - persist_to_workspace:
          # Must be an absolute path, or relative path from working_directory. This is a directory on the container which is
          # taken to be the root directory of the workspace.
          root: /tmp/
          # Must be relative path from root
          paths:
            - fe_coverage
  create-coverage-report:
    docker:
      - image: cimg/node:16.19.0
    steps:
      - checkout
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Install Dependencies
          command: npm install
      - run:
          name: "Run tests and create coverage html report"
          command: |
            if [ "$SKIP_FE_COVERAGE_CHECK" == "true" ]; then
              echo "Skipping the job..."
              exit 0  # Exit with success status to skip the job
            fi

            set -o pipefail
            npm run test:coverage-badges
          when: on_success
      - run:
          name: "Update PR with the coverage report"
          command: |
            if [ "$SKIP_FE_COVERAGE_CHECK" == "true" ]; then
              echo "Skipping the job..."
              exit 0  # Exit with success status to skip the job
            fi
            # Load the environment variables from the workspace
            echo "Loading environment variables from the workspace..."
            ls /tmp/workspace
            cat /tmp/workspace/fe_coverage
            source /tmp/workspace/fe_coverage

            # Store the link to the coverage report artifact
            test_badges_content="<br>[![Branches]($COVERAGE_ARTIFACTS_URL/badge-branches.svg)]($ARTIFACT_URL) [![Functions]($COVERAGE_ARTIFACTS_URL/badge-functions.svg)]($ARTIFACT_URL) [![Lines]($COVERAGE_ARTIFACTS_URL/badge-lines.svg)]($ARTIFACT_URL) [![Statements]($COVERAGE_ARTIFACTS_URL/badge-statements.svg)]($ARTIFACT_URL)"
            echo "ARTIFACT URL: $ARTIFACT_URL"
            echo "PR_API_ENDPOINT: $PR_API_ENDPOINT"

            # Setup the hidden comment and new comment
            HIDDEN_COMMENT_START="<!-- Jest Coverage Comment:Begin -->"
            HIDDEN_COMMENT_END="<!-- Jest Coverage Comment:End -->"
            HIDDEN_COMMENT="$HIDDEN_COMMENT_START $HIDDEN_COMMENT_END"
            NEW_COMMENT="$test_badges_content"
            echo "New comment: $HIDDEN_COMMENT $NEW_COMMENT"

            # Create the JSON body for the comment
            pr_comment_body="$HIDDEN_COMMENT $NEW_COMMENT"

            # Get all comments for the PR
            COMMENTS=$(curl -H "Authorization: Bearer $GITHUB_TOKEN" "$PR_API_ENDPOINT/comments")
            echo "Comments: $COMMENTS"

            # Find the existing comment with the hidden marker
            COMMENT_ID=$(echo "$COMMENTS" | jq -r --arg COMMENT "$HIDDEN_COMMENT_START" '.[] | select(.body | contains($COMMENT)) | .id')
            echo "Comment ID: $COMMENT_ID" 

            # If the comment was found, delete it and create a new one
            response_code=0
            if [ "$COMMENT_ID" != "" ]; then
              echo "Existing coverage comment found. Deleting it..."
              authHeader="Authorization:Bearer $GITHUB_TOKEN"
              API_URL="$ISSUES_API_ENDPOINT/comments/$COMMENT_ID"
              curl_command=(-X DELETE "$API_URL" -H "$authHeader")
              # Execute the curl command and delete the existing comment
              $(curl "${curl_command[@]}")

              # Write the comment
              echo "Creating a new coverage comment..."
              response_code=$(./.circleci/helpers/write_pr_comment.sh NEW_COMMENT)
            else
              # Write the comment
              echo "Creating a new coverage comment..."
              response_code=$(./.circleci/helpers/write_pr_comment.sh NEW_COMMENT)
            fi

            echo "response_code: $response_code"
            if [[ "$response_code" =~ ^2[0-9][0-9]$ ]]; then
              echo "Curl request was successful with HTTP status code $response_code"
            else
              echo "Curl request failed with HTTP status code $response_code"
              exit 1  # Fail the CircleCI job
            fi
          when: always
      - store_artifacts:
          path: coverage

# Orchestrate jobs using workflows
# See: https://circleci.com/docs/configuration-reference/#workflows
workflows:
  test-workflow:
    jobs:
      - say-hello
  test-coverage-workflow:
    jobs:
      - create-coverage-report-prereq
      - create-coverage-report:
          requires:
            - create-coverage-report-prereq
